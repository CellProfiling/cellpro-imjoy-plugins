<docs lang="markdown">
  [TODO: write documentation for this plugin.]
  </docs>
  
  <config lang="json">
  {
    "name": "SingleCellAnnotator",
    "type": "window",
    "tags": [],
    "ui": "",
    "version": "0.1.54",
    "api_version": "0.1.7",
    "description": "Annotate images for HPA single-cell image classification",
    "icon": "extension",
    "inputs": null,
    "outputs": null,
    "env": "",
    "permissions": [],
    "requirements": [
        "https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js",
        "https://static.imjoy.io/spectre.css/spectre.min.css",
        "https://static.imjoy.io/spectre.css/spectre-exp.min.css",
        "https://static.imjoy.io/spectre.css/spectre-icons.min.css",
        "https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.1.1/css/ol.css",
        "https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.1.1/build/ol.js"
    ],
    "dependencies": [],
    "defaults": {"fullscreen": true},
    "runnable": true
  }
  </config>
  
  <script lang="javascript">
  const servers = {
    'development': 'https://wet-grasshopper-41.telebit.io',
    'production': 'https://unlucky-shrimp-3.telebit.io',
    'localhost': 'http://127.0.0.1:5000'
  }
  
  const Map = ol.Map;
  const View = ol.View;
  const Draw = ol.interaction.Draw;
  const Modify = ol.interaction.Modify;
  const Select = ol.interaction.Select;
  const defaultInteractions = ol.interaction.defaults;
  const TileLayer = ol.layer.Tile;
  const Style = ol.style.Style;
  const Fill = ol.style.Fill;
  const Stroke = ol.style.Stroke;
  const Text = ol.style.Text;
  const VectorLayer = ol.layer.Vector;
  const OSM = ol.source.OSM;
  const VectorSource = ol.source.Vector;
  const MousePosition = ol.control.MousePosition;
  const LayerSwitcher = ol.control.LayerSwitcher;
  const Zoomify = ol.source.Zoomify;
  const Static = ol.source.ImageStatic;
  const ImageLayer = ol.layer.Image;
  const Projection = ol.proj.Projection;
  const createStringXY = ol.coordinate.createStringXY;
  const DragAndDrop = ol.interaction.DragAndDrop;
  const GeoJSON = ol.format.GeoJSON;
  const RasterSource = ol.source.Raster;
  const getWidth = ol.extent.getWidth;
  const getCenter = ol.extent.getCenter;
  const Layer = ol.layer.Layer;
  const fromLonLat = ol.proj.fromLonLat;
  const toLonLat = ol.proj.toLonLat;
  const CircleStyle = ol.style.Circle;
  const defaultControls = ol.control.defaults;
  
  function mobileAndTabletcheck() {
    var check = false;
    (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
    return check;
  };
  
  async function getMeta(url) {
      return new Promise((resolve, reject) => {
          let img = new Image();
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = url;
      });
  }
  
  async function getImageData(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas')
          canvas.width = img.width
          canvas.height = img.height
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0,0);
          const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data
          const data = new Uint8Array(new ArrayBuffer(canvas.width * canvas.height))
          for(let i=0;i<canvas.width*canvas.height;i++){
            data[i] = imgData[i*4];
          }
          resolve({data: data, width: canvas.width, height: canvas.height})
        };
        img.onerror = reject;
        img.crossOrigin = "Anonymous";
        img.src = url;
    });
  };
  
  const colormap = {'Microtubule': 0, 'Protein': 1, 'ER': 0, 'Nuclei': 2, 'Mask': 3}
  
  async function composeChannels(channels, channel_settings, alpha, brightness){
    if(alpha<0) alpha = 0;
    if(alpha>1) alpha = 1;
    brightness = brightness || 1.0;
    const rgb_channels = []
    const canvas = document.createElement('canvas') 
    for(let k in channel_settings){
      if(channels[k] && colormap.hasOwnProperty(k)){
        if(channel_settings[k].show){
          const imgData = await getImageData(channels[k]);
          rgb_channels[colormap[k]] = imgData;
          canvas.width = imgData.width
          canvas.height = imgData.height
        }
      }
      if(!colormap.hasOwnProperty(k)){
        console.warn('No color map defined for ' + k)
      }
    }
    const ctx = canvas.getContext('2d');
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const channel_offset = canvas.width * canvas.height * 4
    let i, j, v;
    const data = imgData.data
    // set color channels
    for(j=0;j<3;j++){
      if(rgb_channels[j]){
        const src = rgb_channels[j].data;
        for(i=0;i<channel_offset;i++){
          if(brightness===1){
            data[i*4+j] = src[i]
          }
          else{
            v = src[i]*brightness;
            data[i*4+j] = v>255?255:parseInt(v);
          }
        }
      }
    }
    // set alpha channel
    if(rgb_channels[3]){
      const src = rgb_channels[3].data;
      for(i=0;i<channel_offset;i++){
        if(src[i]>0){
          data[i*4+3] = parseInt(alpha*255);
        }
        else{
          data[i*4+3] = 255;
        }
      }
    }
    else{
      for(i=0;i<channel_offset;i++){
        data[i*4+3] = 255; 
      }
    }
    ctx.putImageData(imgData, 0, 0);
    return {url: canvas.toDataURL(), width: canvas.width, height: canvas.height}
  }
  
  const imageDataTemplate = {
    extend: null,
    cell_id: null,
    mask_geojson: null,
    label_display_mode: null,
    channels: null,
    location: null,
    discarded: false,
    mask_adjusted: false,
    location_changed: false,
    brightness: 1.0,
  };
  
  const LIMS_LOCATION_LABELS = {
      "Nuclear localizations":
      [
          "Nucleoplasm",
          "Nuc membrane",
          "Nucleoli",
          "Nucleoli Fibrillar center",
          "Nucl speckles",
          "Nuclear bodies",
          "Kinetochore",
          "Mitotic chromosome",
      ],
    "Secretory":
      [
          "ER",
          "Golgi",
          "Vesicles",
          "Peroxisomes",
          "Endosomes",
          "Lysosomes",
      ],
    "Cytoskeletal localizations":
      [
          "Csk(Int Fil)",
          "Csk(actin)",
          "Focal Adhesions",
          "Csk(mt)",
          "Csk(mt end)",
          "Csk(cyt bridge)",
          "Midbody",
          "Midbody ring",
          "Cleavage furrow",
          "Mitotic spindle",
          "Primary cilia",
          "Centriolar satelite",
          "Centrosome",
      ],
    "Others":
      [
          "Lipid droplets",
          "Plasma membrane",
          "Cell Junctions",
          "Mitochondria",
          "Aggresome",
          "Cytosol",
          "Cytoplasmic bodies",
          "Rods & Rings",
    ],
  }
  
  const LIMS_TO_IF_CSV = {
    "Nucleoplasm": "Nucleoplasm",
    "Nuc membrane": "Nuclear membrane",
    "Nucleoli": "Nucleoli",
    "Nucleoli Fibrillar center": "Nucleoli fibrillar center",
    "Nucl speckles": "Nuclear speckles",
    "Nuclear bodies": "Nuclear bodies",
    "Kinetochore": null,
    "Mitotic chromosome": "Mitotic chromosome",
  
    "ER": "Endoplasmic reticulum",
    "Golgi": "Golgi apparatus",
    "Vesicles": "Vesicles",
    "Peroxisomes": "Peroxisomes",
    "Endosomes": "Endosomes",
    "Lysosomes": "Lysosomes",
  
    "Csk(Int Fil)": "Intermediate filaments",
    "Csk(actin)": "Actin filaments",
    "Focal Adhesions": "Focal adhesion sites",
    "Csk(mt)": "Microtubules",
    "Csk(mt end)": "Microtubule ends",
    "Csk(cyt bridge)": "Cytokinetic bridge",
    "Midbody": "Midbody",
    "Midbody ring": "Midbody ring",
    "Cleavage furrow": "Cleavage furrow",
    "Mitotic spindle": "Mitotic spindle",
    "Primary cilia": null,
    "Centriolar satalite": "Centriolar satellite",
    "Centrosome": "Centrosome",
    "Lipid droplets": "Lipid droplets",
    "Plasma membrane": "Plasma membrane",
    "Cell Junctions": "Cell Junctions",
    "Mitochondria": "Mitochondria",
    "Aggresome": "Aggresome",
    "Cytosol": "Cytosol",
    "Cytoplasmic bodies": "Cytoplasmic bodies",
    "Rods & Rings": "Rods & Rings",
      
  }
  
  const app = new Vue({
    el: '#app',
    data: {
      viewProxy: null,
      renderWindow: null,
      interactor: null,
      renderer: null,
      modifyInteraction: null,
      drawInteraction: null,
      itkInteraction: null,
      draw_mask_mode: true,
      freehand_mode: true,
      vector_source: null,
      selected_feature: null,
      loading: false,
      // develop image parsing
      selected_server_url: null,
      servers: servers,
      select: null,
      current_panel: 'login',
      user:{
        username: "",
        password: "",
        access_token: null
      },
      mask_history: [],
      channel_settings: {},
      alpha: 0.2,
      hide_controls: false,
      show_segmentation: true,
      default_extend_value: 50,
      current_extend_value: 50,
      statistics: {},
      // from here this is communication to backend, to develop/activate
      tasks: null,
      current_task_name: null,
      cell_per_batch: 10,
      loaded_image_list: null,
      cached_image_data: [],
      current_image_data: null,
      current_image_index: 0,
      loading_cache: false,
      innerHeight: '100vh',
      isMobile: false,
      version: null,
      LIMS_LOCATION_LABELS: LIMS_LOCATION_LABELS,
      LIMS_TO_IF_CSV: LIMS_TO_IF_CSV,
      LIMS_VALUES: Object.values(LIMS_TO_IF_CSV)
    },
    mounted(){
      this.$nextTick(async()=>{
        this.version = await api.getConfig('_version');
      })
      this.isMobile = mobileAndTabletcheck()
      window.onresize = ()=>{
        document.body.height = window.innerHeight;
        this.innerHTML = window.innerHeight + 'px';
        this.$forceUpdate()
      }
      window.onresize();
      this.selected_server_url = this.servers['production']
      document.addEventListener('keydown', async (event)=>{
        if(this.current_panel==='imageviewer'){
          if(event.shiftKey && event.code ==='Equal' || ['+', 'Plus', 'NumpadAdd'].includes(event.code)){
            this.current_image_data.brightness = this.current_image_data.brightness * 1.3
            this.displayMap(this.current_image_data.channels, this.channel_settings, this.current_image_data.brightness);
          }
          else if(['-', 'Minus', 'NumpadSubtract'].includes(event.code)){
            this.current_image_data.brightness = this.current_image_data.brightness / 1.3
            this.displayMap(this.current_image_data.channels, this.channel_settings, this.current_image_data.brightness);
          }
          else if(event.code === 'KeyY'){
            if(this.current_image_data.label_display_mode==='single'){
              this.selectLocation(true)
            }
          }
          else if(event.code === 'KeyN'){
            if(this.current_image_data.label_display_mode==='single'){
              this.selectLocation(false)
            }
          }
          else if(event.code === 'ArrowRight'){
            this.nextImage()
          }
          else if(event.code === 'ArrowLeft'){
            this.previousImage()
          }
          else if(event.code === 'KeyD'){
            this.toggleDiscard()
          }
          else if(event.code === 'KeyR'){
            if(this.current_task_name === 'segmentation'){
              this.startRedrawAnnotation()
            }
          }
          else if(event.code === 'KeyS'){
            if(this.current_image_data.location_changed){
              this.uploadAnnotation();
            }
            if(this.current_image_data.mask_adjusted){
              this.saveMaskAnnotation()
            }
          }
          else if(event.code === 'Escape'){
            this.home()
          }
          else if(event.code === 'KeyB'){
            this.current_extend_value = parseInt(await api.prompt("Please enter a pixel number for extending the image area surrounding the cell:", "300"))
            if( !this.current_extend_value || this.current_extend_value<=0){
              this.current_extend_value = this.default_extend_value
            }
            else if(this.current_extend_value>2048){
              this.current_extend_value = this.default_extend_value
            }
            this.reloadImage()
          }
          // alpha channel mask
          else if(event.code === 'KeyA'){
            if(this.channel_settings['Mask'].show)
              this.channel_settings['Mask'].show = false;
            else
              this.channel_settings['Mask'].show = true;
            this.displayMap(this.current_image_data.channels, this.channel_settings);
          }
          // ER
          else if(event.code === 'KeyE'){
            if(this.channel_settings['ER'].show)
              this.channel_settings['ER'].show = false;
            else
              this.channel_settings['ER'].show = true;
            this.displayMap(this.current_image_data.channels, this.channel_settings);
          }
          // Microtubule
          else if(event.code === 'KeyT'){
            if(this.channel_settings['Microtubule'].show)
              this.channel_settings['Microtubule'].show = false;
            else
              this.channel_settings['Microtubule'].show = true;
            this.displayMap(this.current_image_data.channels, this.channel_settings);
          }
          // Nuclei
          else if(event.code === 'KeyI'){
            if(this.channel_settings['Nuclei'].show)
              this.channel_settings['Nuclei'].show = false;
            else
              this.channel_settings['Nuclei'].show = true;
            this.displayMap(this.current_image_data.channels, this.channel_settings);
          }
          // Protein
          else if(event.code === 'KeyP'){
            if(this.channel_settings['Protein'].show)
              this.channel_settings['Protein'].show = false;
            else
              this.channel_settings['Protein'].show = true;
            this.displayMap(this.current_image_data.channels, this.channel_settings);
          }
          else if(event.code === 'KeyH'){
            if(this.hide_controls){
              this.hide_controls = false
            } 
            else{
              this.hide_controls = true
            }
          }
          else if(event.code ==='Backspace' || event.code ==='Delete'){
            if(this.current_task_name==='segmentation'){
              this.deleteAnnotation()
            }
          }
          else if(event.code ==='KeyZ' && (event.metaKey || event.ctrlKey)){
            if(this.current_task_name==='segmentation'){
              this.undoAnnotation()
            }
          }
          else if(event.code ==='KeyM'){
            if(this.current_task_name==='segmentation'){
              if(this.show_segmentation) this.show_segmentation = false
              else this.show_segmentation = true
              this.vector_source.changed()
            }
          }
          this.$forceUpdate()
        }
      })
      // make sure the key binding works
      document.addEventListener('mouseenter', e => {
        window.focus();
      });
      document.addEventListener('click', e => {
        window.focus();
      });
    },
    computed: {
      unsupported_locations: function(){
        const locs = {}
        if(this.current_image_data.location){
          for(let k in this.current_image_data.location){
            if(!this.LIMS_VALUES.includes(k)){
              locs[k] = this.current_image_data.location[k]
            }
          }
        }
        return locs      
      }
    },
    methods: {
      info(){
        api.alert(`====== Hot keys ======
        ======Navigation=====
        ➕: Increase brightness
        ➖: Decrease brightness
        ➡️: Next image
        ⬅️: Back
        ======Annotation=====
        Y: Yes
        N: No
        D: Discard (toggle)
        ======Mask=====
        S: Save mask
        Delete: delete selected mask
        Ctrl+Z: Undo
        R: Redraw mask
        B: Extend image region
        M: Show/hide segmentation mask
        ======Channels=====
        A: Alpha mask channel (toggle)
        E: ER channel (toggle)
        T: Microtubule channel (toggle)
        I: Nuclei channel (toggle)
        P: Protein channel (toggle)
        ======Others=====
        H: Hide all controls (toggle)
        Esc: Quit annotation
        `)
      },
      async login(){
        const formData = new FormData();
        formData.append('username', this.user.username);
        formData.append('password', this.user.password);
        try{
           const response = await fetch(this.selected_server_url + "/login", {
            method: 'POST',
            mode: 'cors',
            body: formData
          })
          if(response.status === 200){
            const res = await response.json()
            if(res.success){
              if(!res.access_token){
                api.alert('JWT access token required, please make sure you are using the latest backend.');
                return
              }
              this.user.role = res.role
              this.user.access_token = res.access_token
              this.current_panel = 'task_selection';
              await this.getTaskList()
            }else{
              api.alert('Failed to login, error: ' + res.error);
            }
          }else{
            api.alert('Response Status' + response.status)
          }
        }
        catch(e){
          api.alert("Cannot login to the server, error: " + e)
        }
      },
      async getStatistics(){
        const response2 = await fetch(this.selected_server_url + "/statistics", {
          method: 'GET',
          headers: {'Authorization': `Bearer ${this.user.access_token}`},
        })
        const res2 = await response2.json()
        this.statistics = res2.statistics
        console.log( this.statistics )
      },
      async getTaskList(){
        const response2 = await fetch(this.selected_server_url + "/tasks", {
          method: 'GET',
          headers: {'Authorization': `Bearer ${this.user.access_token}`},
        })
        const res2 = await response2.json()
        this.tasks = res2.tasks
      },
      async fetchURLData (sub_url){
        const response = await fetch(this.selected_server_url + sub_url, {
          method: 'GET',
          headers: {'Authorization': `Bearer ${this.user.access_token}`},
        })
        if(response.status === 200){
          const res = await response.json()
          if (res.success){
            return res
          }else{
            api.showMessage('Internal server error: ' + res.error)
            throw 'Internal server error: ' + res.error
          }
        }else{
          api.showMessage('Response Status:' + response.status)
          throw 'Response Status:' + response.status
        }
      },
      async chooseTask (task_name){
        this.current_task_name = task_name;
        this.loading = true;
        this.channel_settings = {};
        this.getNewImageBatch(this.current_task_name, true);
      },
      async fetchCellImage(cell_id){
        const imageData = JSON.parse(JSON.stringify(imageDataTemplate));
        imageData.cell_id = cell_id;
        let image_url = "/images/" + this.current_task_name + "/" + imageData.cell_id;
        imageData.extend = this.current_extend_value;
        image_url += "?extend="+imageData.extend+"&maskout=1";
        const response = await this.fetchURLData(image_url)
        imageData.bbox = response.bbox;
        imageData.mask_geojson = response.mask;
        //ER, Microtubule, Nuclei, Protein,
        imageData.channels = response.images;
        if(response.location){
          locations = Object.keys(response.location);
          if(locations.length==1){
            imageData.label_display_mode = 'single'
            imageData.single_location = locations[0];
            imageData.location = response.location;
          }
          else
          { 
            imageData.label_display_mode = 'multiple'
            imageData.location = response.location;
          }
          imageData.saved_location = Object.assign({}, imageData.location)
  
          
        }
        else{
          imageData.label_display_mode = 'mask'
        }
        // record the current cell indice list
        this.updateSavedCellIdx(imageData)
  
        return imageData
      },
      updateSavedCellIdx(imageData){
        imageData.saved_cell_idx_list = []
        
        const features = imageData.mask_geojson.features;
        imageData.max_cell_id = -1
        for (let i = 0; i < features.length; i++){
          if(features[i].properties && typeof features[i].properties.cell_idx === 'number'){
            if(imageData.max_cell_id< features[i].properties.cell_idx){
              imageData.max_cell_id = features[i].properties.cell_idx
            }
          }
        }
  
        for (let i = 0; i < features.length; i++){
          features[i].properties = features[i].properties || {type: 'cell'}
          // make sure one cell has one id
          if(typeof features[i].properties.cell_idx !== 'number'){
            imageData.max_cell_id++;
            features[i].properties.cell_idx = imageData.max_cell_id;
          }
          imageData.saved_cell_idx_list.push(features[i].properties.cell_idx)
        }
      },
      getMaskDiff(imageData){
        const cell_idx_max = Math.max(...imageData.saved_cell_idx_list);
        const features = this.current_image_data.mask_geojson.features;
        let new_cell_idx = 0;
        for (let k = 0; k < features.length; k++){
          if(features[k].properties && typeof features[k].properties.cell_idx === 'number'&& features[k].properties.cell_idx > new_cell_idx){
            new_cell_idx = features[k].properties.cell_idx
          }
        };
        const new_cell_idx_list = [];
        for (let i = 0; i < features.length; i++){
          features[i].properties = features[i].properties || {}
          if(!features[i].properties.label){
            new_cell_idx += 1
            features[i].properties.cell_idx = new_cell_idx;   
            features[i].properties.label = 'cell'
          };
          new_cell_idx_list.push(features[i].properties.cell_idx)            
        };
        const removed = [];
        const added = [];
        for (let i=0; i < imageData.saved_cell_idx_list.length; i++){
          if(!(new_cell_idx_list.includes(imageData.saved_cell_idx_list[i]))){
            removed.push(imageData.saved_cell_idx_list[i])
          }
        };
        for (let j = 0; j < new_cell_idx_list.length; j++){
          if (!(imageData.saved_cell_idx_list.includes(new_cell_idx_list[j]))){
            added.push(new_cell_idx_list[j])
          }
        };
        return {added, removed}
      },
      async getNewImageBatch(task_name, init){
        if(!this.isMobile) api.showStatus('Loading a new batch...')
        if(this.loading_cache){
          if(task_name === this.loading_cache){
            return
          }
          else{
            // switch tasks
            this.cached_image_data = []
          }
        }
        try{
          this.loading_cache = task_name;
          let url = "/tasks/" + task_name + "?cell_num=" + this.cell_per_batch
          if(init){
            url = url + '&init=1'
          }
          const response = await this.fetchURLData(url);
          this.loaded_image_list  =response.cells;
          if(this.loaded_image_list.length<=0){
            api.showMessage('No more images in this task.')
            return
          }
          for(let i=0;i< this.loaded_image_list.length; i++){
            if(task_name !== this.loading_cache){
              console.error('Switching tasks, quit caching')
              break
            }
            if(!this.current_task_name){
              api.showProgress(0)
              return
            }
            const cell_id = this.loaded_image_list[i];
            api.showProgress((i+1)/this.loaded_image_list.length)
            const imageData = await this.fetchCellImage(cell_id)
            if(!this.current_image_data && this.current_task_name){
              this.showImage(imageData)
              this.$forceUpdate();
            }
            this.cached_image_data.push(imageData)
          }
          // remove older images
          if(this.cached_image_data.length>this.cell_per_batch*3){
            this.cached_image_data = this.cached_image_data.slice(this.cell_per_batch)
            console.log('Removing images from the cache.',  this.cached_image_data.length)
          }
          api.showProgress(100)
          if(!this.isMobile) api.showStatus(`A new batch with ${this.loaded_image_list.length} images loaded`)
          this.loadMoreIfNeeded();
        }
        catch(e){
          console.error(e)
        }
        finally{
          this.loading_cache = false;
        }
      },
      async previousImage(){
        await this.checkNewMask()
        if(this.current_image_data.location_changed){
          await this.uploadAnnotation();
        }
        this.current_image_index = this.cached_image_data.indexOf(this.current_image_data)
        if(this.current_image_index<=0){
          this.current_image_index = 0;
        }
        else{
          this.current_image_index--;
        }
        await this.showImage(this.cached_image_data[this.current_image_index]);
      },
      loadMoreIfNeeded(){
        this.current_image_index = this.cached_image_data.indexOf(this.current_image_data)
        // when we reach 70% of the the cached images
        if(this.current_image_index>this.cached_image_data.length*0.7){
          this.getNewImageBatch(this.current_task_name)
        }
      },
      async confirmAnnotation(){
        this.current_image_data.unsure = false;
        this.current_image_data.discarded = false;
        this.current_image_data.location_changed = true;
        await this.nextImage();
      },
      async unsureAnnotation(){
        this.current_image_data.unsure = !this.current_image_data.unsure;
        this.current_image_data.discarded = false;
        this.current_image_data.location = Object.assign({}, this.current_image_data.saved_location)
        this.current_image_data.location_changed = true;
        await this.uploadAnnotation();
      },
      async nextImage(){
        this.loadMoreIfNeeded();
        await this.checkNewMask()
        if(this.current_image_data.location_changed){
          await this.uploadAnnotation();
        }
        this.current_image_index++;
        if(this.cached_image_data[this.current_image_index])
        await this.showImage(this.cached_image_data[this.current_image_index]);
      },
      async checkNewMask(){
        if(!this.current_image_data.mask_adjusted){
         return 
        }
        if(this.current_task_name === 'segmentation'){
           await this.uploadAnnotation();
        }
        else{
          if(this.vector_source && this.vector_source.getFeatures().length>0){
            const anwser = await api.confirm("Would you like to save the mask annotation?")
            if(anwser){
              if(!await this.saveMaskAnnotation()){
                return
              }
            }
            else{
              this.stopMaskAnnotation()
              this.current_image_data.mask_adjusted = false;
            }
          }
          else{
            this.stopMaskAnnotation()
          }
        }
  
      },
      async showImage(imageData){
        if(!imageData){
          api.showStatus('No more image to show.')
          console.error('no image data to show.')
          return
        }
        if(!this.isMobile) api.showStatus(imageData.cell_id)
        console.log('current image: ', imageData)
        this.current_image_data = imageData;
        imageData.start_time = new Date().getTime();
        // annotation viewer
        this.current_panel = 'imageviewer';
        if(!this.draw_mask_mode){
          this.stopMaskAnnotation()
        }
        if(this.draw_mask_mode && imageData.extend != this.current_extend_value){
          this.reloadImage()
        }
        else{
          this.$nextTick(async ()=>{
            this.loading = true;
            window.onresize();
            try{
                await this.displayMap(imageData.channels, this.channel_settings);
                this.showMaskAnnotation(imageData.mask_geojson);
            }
            catch(e){
              console.error(e)
            }
            finally{
              this.loading = false;
            }
          })
        };
      },
      // extend Image
      async reloadImage(){
        this.loading = true;
        this.current_image_index = this.cached_image_data.indexOf(this.current_image_data);
        const imageDataOld = this.current_image_data;
        const imageData = await this.fetchCellImage(imageDataOld.cell_id)
        imageDataOld.mask_geojson = imageData.mask_geojson;
        imageDataOld.channels = imageData.channels;
        imageDataOld.extend = imageData.extend;
        imageDataOld.mask_adjusted = imageData.mask_adjusted;
        if(this.current_image_data.cell_id === imageDataOld.cell_id){
          await this.showImage(imageDataOld)
        }
        this.loading = false;
      },
      async uploadAnnotation(){
        // skip upload annotation if image is annotated and no new change
        if ((!this.current_image_data.mask_adjusted)&&(!this.current_image_data.location_changed)){
          return
        }
        // Default options are marked with *
        const sendData = {}
        sendData.discarded = this.current_image_data.discarded;
        if(this.current_image_data.start_time){
          this.current_image_data.time_elapsed = new Date().getTime() - this.current_image_data.start_time;
          sendData.start_time = this.current_image_data.start_time;
          sendData.time_elapsed = this.current_image_data.time_elapsed;
        }
  
        if(!sendData.discarded){
          if (this.current_image_data.location_changed){
            if(this.current_image_data.unsure){
              sendData.location = 'unsure'
            }
            else{
              sendData.location = this.current_image_data.location;
            }
            if(typeof sendData.location === 'object'){
              let noLocation = true;
              for (loc in sendData.location){
                if(sendData.location[loc] === null){
                  sendData.location[loc] = false
                }
                else{
                  noLocation = false;
                }
              }
              if (noLocation && this.current_image_data.label_display_mode==='multiple'){
                const anwser = await api.confirm("No location label selected, is that correct?")
                if (!anwser){
                  return
                }
              };
            }
          };
          if (this.current_image_data.mask_adjusted){
            // sendData
            sendData.extend = this.current_image_data.extend;
            sendData.bbox = this.current_image_data.bbox;
            // set the masks
            const allFeatures = this.vector_source.getFeatures();
            const format = new ol.format.GeoJSON();
            const routeFeatures = format.writeFeaturesObject(allFeatures, {decimals: 1});
            routeFeatures['bbox'] = this.current_image_data.mask_geojson.bbox;
            this.current_image_data.mask_geojson = routeFeatures;
            sendData.mask = this.current_image_data.mask_geojson;
            sendData.mask_diff = this.getMaskDiff(this.current_image_data);
          };
        }
        // this is the url to send the current annotation
        const sub_url = "/annotations/" + this.current_task_name + "/" + this.current_image_data.cell_id;
        const url_post = this.selected_server_url + sub_url;
        const response = await fetch(url_post, {
            method: 'POST',
            mode: 'cors',
            cache: 'no-cache',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${this.user.access_token}`,
            },
            body: JSON.stringify(sendData)
          });
        const res= await response.json();
        if(res.success){
          this.current_image_data.mask_adjusted = false;
          this.current_image_data.location_changed = false;
          this.current_image_data.saved_location = Object.assign({}, this.current_image_data.location)
  
          this.updateSavedCellIdx(this.current_image_data)
        }
        else{
          alert('Failed to upload the annotaiton, error: ' + res.error);
          throw new Error('Failed to upload the annotaiton.')
        };
      },
      async drawMaskModeChanged(){
        if(this.draw_mask_mode){
          this.loading = true;
          try{
            this.current_image_data.mask_adjusted=false;
            await this.reloadImage();
          }
          catch(e){
            console.error(e)
          }
          finally{
            this.loading = false;
          }
        }
        else{
          this.checkNewMask()
          this.stopMaskAnnotation()
        }
      },
      async toggleDiscard(){
        this.current_image_data.location_changed = true;
        if(this.current_image_data.discarded){
          this.current_image_data.discarded = false;
        }
        else{
          
          const reasons = [
            "Negative",
            "Out of focus", 
            "artifact",
            "missing channels",
          ]
          let question = "Why do you want to discard this cell?\nPlease type the corresponding number bellow:\n"
          let index = 0
          for(let r of reasons){
            index++;
            question = question + index + ': ' + r + '\n'
          }
          question = question + "\nFor other reason, please specify."
          let reason = await api.prompt(question, "")
          index = parseInt(reason);
          if(!isNaN(index)){
            if(index>0 && index<=reasons.length)
            reason = reasons[index-1]
            else{
              await api.alert('Please type a valid number.')
              return
            }
          }
          if(!reason){
            api.showMessage("Not discarded.")
            return
          }
          this.current_image_data.discarded = reason
        }
        this.$forceUpdate()
        await this.uploadAnnotation();
      },
      showMaskAnnotation(mask_geojson){
        this.vector_source.clear()
        features = (new GeoJSON()).readFeatures(mask_geojson)
        this.vector_source.addFeatures(features)
        this.current_image_data.mask_adjusted = false;
        this.mask_history = []
      },
      async saveMaskAnnotation(){
        const allFeatures = this.vector_source.getFeatures();
        const format = new ol.format.GeoJSON();
        const routeFeatures = format.writeFeaturesObject(allFeatures, {decimals: 1});
        if(this.current_task_name !== 'segmentation'){
          if (!routeFeatures.features.length){
            api.alert('Please draw a cell mask before saving!');
            return false
          }
          if(routeFeatures.features.length>1){
            api.alert('Only one cell mask is allowed!');
            return false
          }
        }
  
        routeFeatures['bbox'] = this.current_image_data.mask_geojson.bbox;
        this.current_image_data.mask_geojson = routeFeatures;
        this.current_image_data.mask_adjusted = true;
        await this.uploadAnnotation()
        api.showMessage('Cell mask saved.')
        if (this.current_task_name !== 'segmentation'){
          this.stopMaskAnnotation()
        }
        await this.reloadImage()
        return true
      },
      async exportAnnotation() {
        const allFeatures = this.vector_source.getFeatures();
  
        const format = new ol.format.GeoJSON();
        const routeFeatures = format.writeFeaturesObject(allFeatures, {decimals: 1});
        routeFeatures['bbox'] = this.current_image_data.mask_geojson.bbox;
        const blob = new Blob([JSON.stringify(routeFeatures)], {
            type: "text/plain;charset=utf-8"
        });
        api.alert(JSON.stringify(blob))
      },
      // go to nextImage after select yes/no.
      async selectLocation(selected){
        this.current_image_data.location[this.current_image_data.single_location] = selected;
        this.current_image_data.location_changed = true;
        await this.nextImage()
      },
      async displayMap(channels, channel_settings, brightness){
        for(let k of Object.keys(channels)){
          if(!channel_settings[k]){
            channel_settings[k] = {name: k, show: true}
            // don't show ER by default
            if(k==='ER'){
              channel_settings[k].show = false;
            }
          }
        }
        let url, extent;
        if(channels.merged){
          url = channels.merged
          const imgObj = await getMeta(url)
          extent = [0, 0, imgObj.width, imgObj.height];
        }
        else{
          const image = await composeChannels(channels, channel_settings, this.alpha, brightness)
          extent = [0, 0, image.width, image.height];
          url = image.url;
        }
  
        const projection = new Projection({
            code: 'image',
            units: 'pixels',
            extent: extent,
        });
  
        const image_source = new Static({
          attributions: '©Human Protein Atlas',
          url: url,
          projection: projection,
          imageExtent: extent
        })
  
        if(this.image_layer && this.map){
          this.map.setView( new View({
            projection: projection,
            center: getCenter(extent),
            zoom: 1,
            minZoom: -10
          }))
          this.image_layer.setSource(image_source)
          return
        }
  
        this.image_layer = new ImageLayer({
          source: image_source,
        })
  
        this.vector_source = new VectorSource();
        this.mask_history = []
        this.vector_source.on('addfeature', (event)=>{
          if(event.feature._undoing){
            delete event.feature._undoing
          }
          else{
            this.mask_history.push({'add': event.feature})
            if(!event.feature.get('cell_idx') && event.feature.get('cell_idx') !== 0){
              this.current_image_data.max_cell_id++      
              event.feature.set('cell_idx', this.current_image_data.max_cell_id)
              event.feature.set('label', 'cell')
            }
          }
          this.current_image_data.mask_adjusted = true
        });
        this.vector_source.on('removefeature', (event)=>{
          if(event.feature._undoing){
            delete event.feature._undoing
          }
          else{
            this.mask_history.push({'remove': event.feature})
          }
          // this.current_image_data.mask_changed.removed.push(event.feature.values_.cell_idx)
          this.current_image_data.mask_adjusted = true
        });
        var vector_layer = new VectorLayer({
          source: this.vector_source
        });
  
        vector_layer.setStyle((feature) => {
          let color_style = new Style({
              fill: new Fill({
                color: 'rgba(255, 255, 255, 0)'
              }),
              stroke: new Stroke({
                  color: this.current_task_name ==='segmentation'? (this.show_segmentation? '#f5d80b91': '#00000000'): '#448aff53',
                  width: 2
              }),
              text: new Text({
                  text: this.current_task_name ==='segmentation'? String(feature.get('cell_idx')): '',
                  font: '14px Calibri,sans-serif',
                  fill: new Fill({
                      color: '#03346f'
                  }),
                  stroke: new Stroke({
                      color: '#d6d37ea6',
                      width: 4
                  })
              })
          });
          return color_style;      
        })
        const select = new Select({
            wrapX: false
        });
        // clear map
        this.$refs.map.innerHTML = ""
        this.map = new Map({
          interactions: ol.interaction.defaults({altShiftDragRotate:false, pinchRotate:false}),
          controls: [],
          layers: [
            this.image_layer,
            vector_layer,
          ],
          target: 'map',
          view: new View({
            projection: projection,
            center: getCenter(extent),
            zoom: 1,
            minZoom: -10
          })
        });
        this.map.addControl(new MousePosition({
            coordinateFormat: createStringXY(0)
        }));
        this.map.addInteraction(select);
        this.select = select
        select.on('select', (e)=>{
          if(e.selected && e.selected.length>0)
              this.selected_feature = e.selected
            else{
               this.selected_feature = null
            }
        })
        if(this.current_task_name === 'segmentation' && !this.isMobile){
          this.startMaskAnnotation(this.vector_source, this.freehand_mode)
        }
        else{
          this.freehand_mode = false;
        }
      },
      startRedrawAnnotation() {
        this.vector_source.clear()
        this.startMaskAnnotation(this.vector_source, this.freehand_mode)
      },
      freehandChanged(){
          if (this.current_task_name !== 'segmentation') return
          if(this.freehand_mode)
          this.startMaskAnnotation(this.vector_source, this.freehand_mode)
          else{
            if(this.isMobile){
              this.stopMaskAnnotation()
            }
          }
      },
      async undoAnnotation() {
        if(this.mask_history.length>0){
          const action = this.mask_history.pop()
          if(action.add){
             const allFeatures = this.vector_source.getFeatures();
            allFeatures.forEach((feature)=>{
              if(action.add === feature){
                feature._undoing = true
                this.vector_source.removeFeature(feature);
                this.select.getFeatures().remove(feature);
              }
            });
          }
          else if(action.remove){
            action.remove._undoing = true
            this.vector_source.addFeature(action.remove)
          }
        }
      },
      // to remove selected annotation
      async deleteAnnotation() {
        if (this.vector_source) {
          const features = this.select.getFeatures()
          features.forEach((feature)=>{
              this.vector_source.removeFeature(feature);
              this.select.getFeatures().remove(feature);
          });
        }
      },
      startMaskAnnotation(source, freehand){
        if(!source){
          console.error("Please specify an annotation layer source")
        }
        if (this.modifyInteraction) {
          this.map.removeInteraction(this.modifyInteraction)
        }
        this.modifyInteraction = new Modify({source: source});
        this.map.addInteraction(this.modifyInteraction);
        if (this.drawInteraction) {
          this.map.removeInteraction(this.drawInteraction)
        }
        this.drawInteraction = new Draw({
          source: source,
          type: 'Polygon',
          freehand: freehand
        });
          this.drawInteraction.on('drawend', async (evt) => {
              
          });
        this.map.addInteraction(this.drawInteraction);
        if(this.current_task_name !== 'segmentation'){
          if(this.channel_settings['Mask'])
           this.channel_settings['Mask'].show = false
          this.displayMap(this.current_image_data.channels, this.channel_settings);
        }
      },
      stopMaskAnnotation(){
        if(this.channel_settings['Mask'])
        this.channel_settings['Mask'].show = true
        this.displayMap(this.current_image_data.channels, this.channel_settings);
        if(!this.map) return;
        if(this.drawInteraction)
        this.map.removeInteraction(this.drawInteraction);
        if(this.modifyInteraction)
        this.map.removeInteraction(this.modifyInteraction);
      },
      toggleLocation(k){
        if(this.current_image_data.location[k]){
          this.current_image_data.location[k]=false
        }
        else{
          this.current_image_data.location[k]=true
        }
        this.current_image_data.unsure = false;
        this.current_image_data.discarded = false;
        this.current_image_data.location_changed = true;
      },
      home(){
        this.current_panel='task_selection';
        this.current_task_name = null;
        this.current_image_index = 0;
        this.cached_image_data = [];
        this.current_image_data = null
        this.getTaskList();
        // destroy the map
        this.$refs.map.innerHTML = "";
        this.map = null;
        this.$forceUpdate();
      },
      channelSettingsUpdated(event){
        // make sure ER and Microtubule are not turned on at the same time
        if(event.target.name === 'ER' && event.target.value === 'on'){
          if(this.channel_settings['Microtubule']){
            this.channel_settings['Microtubule'].show = false
          }
        }
        else if(event.target.name === 'Microtubule' && event.target.value === 'on'){
          if(this.channel_settings['ER']){
            this.channel_settings['ER'].show = false
          }
        }
        this.$forceUpdate()
        this.displayMap(this.current_image_data.channels, this.channel_settings);
      },
      async showStatistics(){
        await this.getStatistics()
        this.current_panel = 'statistics'
      }
    }
  })
  
  class ImJoyPlugin {
    async setup() {
    }
  
    async run(ctx) {
  
    }
  }
  
  api.export(new ImJoyPlugin())
  </script>
  
  <window>
    <div style="text-align: center;" id="app">
  
      <div class="panel centered-panel" v-if="current_panel=='login'">
        <div class="panel-header">
          <div class="panel-title h2">HPA Image Annotator</div>
          <span>(v{{version}})</span>
        </div>
        <div class="panel-body">
          <div class="form-group">
            <label class="form-label" for="server">Server</label>
            <select class="form-select" v-model="selected_server_url">
              <option>Choose an option</option>
              <option v-for="(url, k) in servers" :value="url">{{k}}</option>
            </select>
          </div>
          <div class="form-group">
            <label class="form-label" for="input-example-1">Name</label>
            <input class="form-input" type="text" name="username" v-model="user.username"  placeholder="username">
          </div>
          <div class="form-group">
            <label class="form-label" for="input-example-1">Password</label>
            <input class="form-input" type="password" name="password" v-model ="user.password" placeholder="password">
          </div>
          <button class="btn" @click="login()">Login</button>
        </div>
        <div class="panel-footer">
          <!-- buttons or inputs -->
        </div>
      </div>
  
  
      <div class="panel centered-panel" v-if="current_panel=='task_selection'">
        <div class="panel-header">
          <div class="panel-title h2">HPA Image Annotator </div> <span>(v{{version}})</span>
          <br>
          <p>Please choose a task:</p>
        </div>
        <div class="panel-body">
          <br>
          <div v-for="(task, task_name) in tasks">
            <progress class="progress" style="width: 288px" :value="task.finished" :max="task.total"></progress>
            <br>
            <button class="btn" style="width: 280px" @click="chooseTask(task_name)"><i class="icon icon-edit"></i>&nbsp; {{task_name}}: {{task.finished}}/{{task.total}}</button>&nbsp;&nbsp;
            <br>
            <br>
          </div>
          <button v-if="user.role === 'admin'" class="btn" style="width: 280px" @click="showStatistics()">Statistics (🚧Under construction)</button>
        </div>
        <div class="panel-footer">
        </div>
      </div>
  
      <div class="panel" v-if="current_panel=='statistics'&&statistics">
         <button style="right: 52px; top: 10px; position: absolute;" class="btn btn-action s-circle" title="refresh" @click="getStatistics()"><i class="icon icon-refresh"></i></button>&nbsp;&nbsp;
        <button style="right: 10px; top: 10px; position: absolute;" class="btn btn-action s-circle" title="home" @click="home()"><i class="icon icon-cross"></i></button>&nbsp;&nbsp;
        <div v-for="(s, k) in statistics">
          <div class="card" style="width: 500px;max-width:100%;">
            <div class="card-body">
              <div class="card-header">
                <div class="card-title h5">{{k}}</div>
              </div>  
              <div v-for="(v, task_name) in s">
                <div class="card-subtitle text-gray">{{task_name}}</div>
                <div v-for="(t, ann_name) in v">
                <span class="chip">{{ann_name}}: {{t}}</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    
      <div class="panel" v-if="current_panel=='imageviewer'&&current_image_data">
        <div v-show="!hide_controls" class="input-group floating-switch">
          <!-- <label class="form-switch">
            <input type="checkbox" v-model="draw_mask_mode" @change="drawMaskModeChanged">
            <i class="form-icon"></i> <span class="hide-on-mobile">Redraw Mask</span>
          </label> -->
          <label class="form-switch " v-show="current_task_name === 'segmentation'">
            <input type="checkbox" v-model="freehand_mode" @change="freehandChanged">
            <i class="form-icon"></i> <span class="hide-on-mobile">Freehand</span>
          </label>
          <button style="background-color:transparent" class="btn btn-action s-circle" title="home" @click="home()"><i class="icon icon-cross"></i></button>&nbsp;&nbsp;
        </div>
  
        <!-- channels -->
        <div v-show="!hide_controls" :style="{bottom: current_image_data.label_display_mode==='multiple'?'-20px': '20px'}" class="form-group floating-channel-btn">
          <label v-if="current_task_name === 'segmentation'" class="form-checkbox channel-controls">
            <input v-model="show_segmentation" @change="vector_source.changed()" name="hide segmentation mask" type="checkbox">
            <i class="form-icon"></i> Segmentation
          </label>
          <label v-for="ch in channel_settings" v-show="ch.name!=='merged'" class="form-checkbox channel-controls">
            <input v-model="ch.show" :name="ch.name" @change="channelSettingsUpdated" type="checkbox">
            <i class="form-icon"></i> {{ch.name}}
          </label>
          
          <button v-if="current_task_name === 'segmentation'||current_image_data.single_location" class="btn btn-sm small-btn channel-controls" :disabled="current_image_data.unsure" :class="{'discarded-btn': current_image_data.discarded}" title="discard" @click="toggleDiscard()">Discard</button>
          <!--<button class="btn btn-sm small-btn channel-controls" title="annotation mode" v-if="draw_mask_mode && (current_task_name !== 'segmentation')" @click="startRedrawAnnotation()">
            <span v-if="!current_image_data.mask_adjusted"><i class="icon icon-edit"></i>&nbsp;Mask</span>
            <span v-else>Remove</span>
          </button>
          <button :disabled="loading" v-show="(current_task_name !== 'segmentation')&&current_image_data.mask_adjusted" style="background-color:white" class="btn btn-sm small-btn channel-controls" @click="saveMaskAnnotation()">Save</button>-->
          <button :disabled="!mask_history||mask_history.length<=0" v-show="current_task_name === 'segmentation'" class="btn btn-sm small-btn channel-controls" @click="undoAnnotation()">Undo</button>
          <button class="btn btn-sm s-circle channel-controls" style="background-color: transparent;" title="info" @click="info()"><i class="icon icon-message"></i></button>
        </div>
        <template v-if="current_image_data.label_display_mode==='multiple'">
          <div v-show="!hide_controls" class="floating-right-btn">
            <div class="columns">
              <template v-for="group in LIMS_LOCATION_LABELS">
                <template v-for="label in group">
                  <button v-if="LIMS_TO_IF_CSV[label] && current_image_data.location[LIMS_TO_IF_CSV[label]] !== undefined" :disabled="current_image_data.discarded || current_image_data.unsure" @click="toggleLocation(LIMS_TO_IF_CSV[label])" class="column btn location-btn" :class="{'selected-location-btn': current_image_data.location[LIMS_TO_IF_CSV[label]]}">{{label.slice(0,12)+(label.length>12?'.': '')}}</button>
                </template>
                <!-- <div class="break hide-on-mobile"></div> -->
              </template>
              <template v-for="(loc, k) in unsupported_locations">
                <button  :disabled="current_image_data.discarded || current_image_data.unsure"  @click="toggleLocation(k)" class="column btn location-btn" :class="{'selected-location-btn': loc}">{{k.slice(0,12)+(k.length>12?'.': '')}}</button>
              </template>
              
            </div>
             <br>
            <div class="btn-group">
              <button :disabled="current_image_data.location_changed || current_image_data.discarded || current_image_data.unsure" class="btn transparent-btn" @click="confirmAnnotation()">&nbsp;Confirm</button>
              <button :disabled="current_image_data.unsure" :class="{'highlight-btn': current_image_data.discarded}" class="btn transparent-btn" @click="toggleDiscard()">Discard&nbsp;</button>
              <button :disabled="current_image_data.discarded" :class="{'highlight-btn': current_image_data.unsure}" class="btn transparent-btn" @click="unsureAnnotation()">Unsure&nbsp;</button>
            </div>
            <br>
            <div class="btn-group">
              <button :disabled="current_image_index===0  || loading" class="btn transparent-btn" @click="previousImage()"><i class="icon icon-back"></i>&nbsp;Back</button>
              <button :disabled="current_image_index>=cached_image_data.length  || loading" class="btn transparent-btn" @click="nextImage()">Next&nbsp;<i class="icon icon-forward"></i></button>
            </div>
          </div>
        </template>
        <template v-if="current_image_data.label_display_mode==='single'">
          <div v-show="!hide_controls" class="btn-group floating-bottom-btn">
            <button :disabled="current_image_index===0 || loading" class="btn transparent-btn" @click="previousImage()"><i class="icon icon-back"></i>&nbsp;Back</button>
            <button :disabled="current_image_data.discarded" class="btn transparent-btn" @click="selectLocation(true)" :class="{'selected-location-btn': current_image_data.location[current_image_data.single_location]===true}"><i class="icon icon-check"></i>&nbsp;Yes</button>
            <button :disabled="current_image_data.discarded" class="btn transparent-btn" @click="selectLocation(false)" :class="{'selected-location-btn': current_image_data.location[current_image_data.single_location]===false}"><i class="icon icon-cross"></i>&nbsp;No</button>
            <button :disabled="current_image_index>=cached_image_data.length || loading" class="btn transparent-btn" @click="nextImage()">Next&nbsp;<i class="icon icon-forward"></i></button>
          </div>
          <span v-show="!hide_controls" class="h3 floating-label">{{current_image_data.single_location}}</span>
        </template>
        <template v-if="current_task_name === 'segmentation'">
          <div v-show="!hide_controls" class="btn-group floating-bottom-btn">
            <button :disabled="current_image_index===0 || loading" class="btn transparent-btn" @click="previousImage()"><i class="icon icon-back"></i>&nbsp;Back</button>
            <button :disabled="current_image_data.discarded || !selected_feature" class="btn transparent-btn" @click="deleteAnnotation()" ><i class="icon icon-cross"></i>Remove&nbsp;</button>
            <button :disabled="current_image_data.discarded || loading" class="btn transparent-btn"  @click="saveMaskAnnotation()"><i class="icon icon-check"></i>
              Save
            </button>
            <button :disabled="current_image_index>=cached_image_data.length || loading" class="btn transparent-btn" @click="nextImage()">Next&nbsp;<i class="icon icon-forward"></i></button>
          </div>
        </template>
        
        <div v-if="loading" class="loading loading-lg floating"></div>
        <div id="map" ref="map" v-show="current_panel=='imageviewer'" :style="{height: innerHeight}"></div>
      </div>
      </div>
    </div>
  
  </window>
  <style lang="css">
    body{
      color: #448aff!important;
      overflow: hidden;
    }
    .centered-panel{
      background-color: #448aff0f;
      width: 400px;
      height: 450px;
      max-height: 100%;
      max-width: 100%;
      left: 50%;
      top: 50%;
      position: absolute;
      -webkit-transform: translate3d(-50%, -50%, 0);
      -moz-transform: translate3d(-50%, -50%, 0);
      transform: translate3d(-50%, -50%, 0);
    }
    .ol-layers:first-child{
      background-color: black;
    }
  
    .floating-label{
      color:#ffefdbc2;
      position: absolute;
      left: 50%;
      z-index: 999;
      top: 40px;
      -webkit-transform: translate3d(-50%, -50%, 0);
      -moz-transform: translate3d(-50%, -50%, 0);
        transform: translate3d(-50%, -50%, 0);
    }
  
    @media screen and (max-width: 800px) {
      .floating-label{
        top: 90px!important;
      }
    }
    
    .floating-switch{
      position: absolute;
      right: 5px;
      z-index: 999;
      top: 10px;
    }
  
    .ol-mouse-position{
      top:unset;
      bottom: 3px;
    }
    @media all and (max-width: 600px) {
      .floating-channel-btn{
        text-align: left!important;
        top: 10px!important;
        bottom: unset!important;
        left: 5px!important;
        -webkit-transform:unset!important;
        -moz-transform:unset!important;
        transform: unset!important;
        bottom: 60px;
      }
      .channel-controls{
        display: block;
      }
    }
  
    @media all and (min-width: 600px) {
      .channel-controls{
        display: inline-block;
      }
    }
  
    .floating-channel-btn{
      text-align: center;
      width: 100%;
      position: absolute;
      left: 50%;
      -webkit-transform: translate3d(-50%, -50%, 0);
      -moz-transform: translate3d(-50%, -50%, 0);
      transform: translate3d(-50%, -50%, 0);
      bottom: 20px;
      z-index: 666;
    }
  
  
    .floating-bottom-btn {
      position: absolute;
      left: calc(50% - 180px);
      bottom: 5px;
      z-index: 999;
    }
    @media all and (max-width: 900px) {
      .floating-right-btn{
        width: 220px!important;
      }
    }
    .floating-right-btn{
      position: absolute;
      right: 3px;
      top: 80px;
      width: 330px;
      z-index: 999;
    }
    .floating-left-btn{
      position: absolute;
      left: 3px;
      top: 80px;
      width: 330px;
      z-index: 999;
    }
    .location-btn {
      padding-top: 0px;
      font-size: small;
      margin-left: 0px;
      height: 26px;
      flex: none;
      width: 110px;
      background-color:#fff3;
    }
    .discarded-btn{
      background-color: rgb(248, 27, 2)!important;
    }
    .highlight-btn{
      background-color: white!important;
    }
    .location-btn:hover, .location-btn:focus{
      background-color:rgba(255, 255, 255, 0.42);
    }
    .selected-location-btn{
      background-color: #3580ff7d!important;
      color: white!important;
    }
    .break {
      flex-basis: 100%;
      height: 0;
    }
    .transparent-btn, .transparent-btn:focus {
      width: 90px;
      background-color:#fff3;
    }
    .transparent-btn:hover {
      background-color:rgba(255, 255, 255, 0.42);
    }
    .small-btn{
      width: 60px;
      background: transparent;
      border: none;
      background-color:#fff3;
      margin-bottom: 3px;
    }
    .floating {
      position: absolute;
      left: 50%;
      top: 30%;
    }
    #toolbar {
      position: absolute;
      top: 112px;
      left: 10px;
    }
    #toolbar > div:nth-child(1){
      fill: #448aff;
    }
  
    .ol-layer{
      top: 0px;
    }
  
    #map{
      max-height: 100%;
      min-height: 50vh!important;
    }
    .icon::before {
      position: relative;
    }
    .navbar {
      padding-left: 10px;
    }
    .navbar .navbar-brand {
      font-size: 1.5rem;
      text-decoration: none;
    }
    
    .mouse-position{
      padding-left: 124px;
      padding-top: 10px;
    }
    
    @media all and (max-width: 512px) { /* Change Width Here */
      .hide-on-mobile {
          display: none;
      }
    }
  </style>
  
