<docs lang="markdown">
[TODO: write documentation for this plugin.]
</docs>

<config lang="json">
{
  "name": "SingleCellAnnotator",
  "type": "window",
  "tags": [],
  "ui": "",
  "version": "0.1.6",
  "api_version": "0.1.7",
  "description": "Annotate images for HPA single-cell image classification",
  "icon": "extension",
  "inputs": null,
  "outputs": null,
  "env": "",
  "permissions": [],
  "requirements": [
      "https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js",
      "https://static.imjoy.io/spectre.css/spectre.min.css",
      "https://static.imjoy.io/spectre.css/spectre-exp.min.css",
      "https://static.imjoy.io/spectre.css/spectre-icons.min.css",
      "https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.1.1/css/ol.css",
      "https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.1.1/build/ol.js",
      "https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js",
      "https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"
  ],
  "dependencies": [],
  "defaults": {"fullscreen": true},
  "runnable": true
}
</config>

<script lang="javascript">
const servers = {
  'development': 'https://wet-grasshopper-41.telebit.io/',
  'production': 'https://unlucky-shrimp-3.telebit.io/',
  'localhost': 'http://127.0.0.1:5000/'
}

const Map = ol.Map;
const View = ol.View;
const Draw = ol.interaction.Draw;
const Modify = ol.interaction.Modify;
const Select = ol.interaction.Select;
const defaultInteractions = ol.interaction.defaults;
const TileLayer = ol.layer.Tile;
const Style = ol.style.Style;
const Fill = ol.style.Fill;
const Stroke = ol.style.Stroke;
const Text = ol.style.Text;
const VectorLayer = ol.layer.Vector;
const OSM = ol.source.OSM;
const VectorSource = ol.source.Vector;
const MousePosition = ol.control.MousePosition;
const LayerSwitcher = ol.control.LayerSwitcher;
const Zoomify = ol.source.Zoomify;
const Static = ol.source.ImageStatic;
const ImageLayer = ol.layer.Image;
const Projection = ol.proj.Projection;
const createStringXY = ol.coordinate.createStringXY;
const DragAndDrop = ol.interaction.DragAndDrop;
const GeoJSON = ol.format.GeoJSON;
const RasterSource = ol.source.Raster;
const getWidth = ol.extent.getWidth;
const getCenter = ol.extent.getCenter;
const Layer = ol.layer.Layer;
const fromLonLat = ol.proj.fromLonLat;
const toLonLat = ol.proj.toLonLat;
const CircleStyle = ol.style.Circle;
const Snap = ol.interaction.Snap;
const defaultControls = ol.control.defaults;

function mobileAndTabletcheck() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

async function getImageMeta(url) {
    return new Promise((resolve, reject) => {
        let img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.crossOrigin = "Anonymous";
        img.src = url;
    });
}

const app = new Vue({
  el: '#app',
  data: {
    viewProxy: null,
    renderWindow: null,
    interactor: null,
    renderer: null,
    modifyInteraction: null,
    drawInteraction: null,
    snapInteraction: null,
    itkInteraction: null,
    anntation_mode: false,
    freehand_mode: true,
    vector_source: null,
    loading: false,
    // develop image parsing
    selected_server_url: null,
    servers: servers,
    select: null,
    current_panel: 'login',
    user:{
      username: "hao",
      password: "GshQvF3GPzeoPAWBpalq"
    },
  // from here this is communication to backend, to develop/activate
    tasks: {
      1:{
        name: null,
        finished: null,
        total: null
      },
      2:{
        name: null,
        finished: null,
        total: null
      },
    },
    current_task_name: null,
    cell_num: '20',
    loaded_image_list: null,
    current_image_data:{
      index: 1,
      image_id: null,
      bbox: null,
      mask_geojson:{
      'type':'FeatureCollection',
      'features':[
        {
          'type':'Feature',
          'geometry':{
          'type':'Polygon',
          'coordinates':null
          },
          'properties':null
        }],
        'bbox':null
      },
      uri: null,
      location: null
    },

    //current_image_index: 1, // to be replaced
    //current_image_bbox: null, // to be replaced
    //current_image_uri: null, // to be replaced
    //current_location: null, // to be replaced
    //image_to_annotate: null,
    backend_url: null,
  // this is for imageviewer test
    record_annotation: null,
    //current_image_geojson_geojson:{
    //'type':'FeatureCollection',
    //'features':[
    //  {
    //    'type':'Feature',
    //    'geometry':{
    //    'type':'Polygon',
    //    'coordinates':null
    //  },
    //  'properties':null
    //}],
    //'bbox':null
  //},
  },
  mounted(){
    this.selected_server_url = this.servers['production']
  },
  methods: {
    async login(){
      const formData = new FormData();
      formData.append('username', this.user.username);
      formData.append('password', this.user.password);
      const response = await fetch(this.selected_server_url + "/login", {
        method: 'POST',
        mode: 'cors',
        credentials: 'include',
        body: formData
      })
      if(response.status === 200){
        const res = await response.json()
        if(res.success){
            const response2 = await fetch(this.selected_server_url + "/tasks", {
            method: 'GET',
            credentials: 'include'
          })
          const res2 = await response2.json()
          data = res2.tasks
          key_index = 1
          for (var key in data) {
            this.tasks[key_index].name = key
            this.tasks[key_index].finished = data[key].finished
            this.tasks[key_index].total = data[key].total
            key_index = key_index + 1
          }
          this.current_panel = 'task_selection';
        }else{
          api.alert('Failed to login, error: ' + res.error);
        }
      }else{
        api.alert('Response Status' + response.status)
      }
    },

    async fetchURLData (sub_url){
      const response = await fetch(this.selected_server_url + sub_url, {
        method: 'GET',
        credentials: 'include'
      })
      if(response.status === 200){
        const res = await response.json()
        if (res.success){
          return res
        }else{
          api.alert('Internal server error: ' + res.error);
        }
      }else{
        api.alert('Response Status:' + response.status)
      }
    },
    // choose task type
    async chooseTask (task_name){
      this.current_task_name = task_name;
      this.initial_loading = true;
      await this.getImageList();
      await this.assignImage();
    },
    // this function is to load image list and assign image
    //loading image list
    async getImageList (){
      const response = await this.fetchURLData("/tasks/" + this.current_task_name + "?cell_num=" + this.cell_num);
      this.current_image_data.index = 0; // index starts from 0
      this.loaded_image_list  =response.cells;
    },
    async previousImage(){
      api.alert('Not implemented.')
    },
    async nextImage(){
      //await this.uploadAnnotation()
      await this.assignImage()
    },
    // should add out of range check for image list
    // fetch the first item to this.current_image_data
    // then give the image index to next
    async assignImage (){
      this.current_image_data.image_id = this.loaded_image_list[this.current_image_data.index];
      this.current_image_data.index = this.current_image_data.index + 1; // for the next image
      // get the data from server
      const response = await this.fetchURLData("/images/" + this.current_task_name + "/" + this.current_image_data.image_id)
      this.current_image_data.mask_geojson.bbox = response.bbox;
      this.current_image_data.bbox = response.bbox;
      this.current_image_data.mask_geojson.features[0].geometry.coordinates = response.mask.geometry.coordinates;
      this.current_image_data.uri = response.image;
      this.current_image_data.location = "Nucleoplasm?"; //response.location;

      // managing loading images
      this.current_panel = 'imageviewer';
      await this.displayMap(this.current_image_data.uri);
      this.showAnnotation()
    },
    async uploadAnnotation (url_post) {
      // Default options are marked with *
      const data = this.user;
      const response = await fetch(url_post, {
          method: 'POST',
          mode: 'cors',
          cache: 'no-cache',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(data)
        });
      const res= await response.json(); 
      if(!res.success){
        alert('Failed to upload the annotaiton, error: ' + res.error);
        throw new Error('Failed to upload the annotaiton.')
      };
    },
    anntation_mode_changed(){
      if(this.anntation_mode){
        this.startAnnotation(this.vector_source, this.freehand_mode)
      }
      else{
        this.stopAnnotation()
      }
    },
    // this is for import and export geojson
    async setFeatures(geojsonObject) {
      let features = (new GeoJSON()).readFeatures(geojsonObject)

      this.draw_feature_list = [...this.draw_feature_list, ...features]
      this.undo_button_flag = true
      this.vector_source.addFeatures(features)
      this.updateFeatureStyle()
    },
    async showAnnotation (){
      features = (new GeoJSON()).readFeatures(this.current_image_data.mask_geojson)
      this.vector_source.addFeatures(features)
      //alert(await JSON.stringify(this.current_image_data.mask_geojson))
    },
    // save annotations
    async saveAnnotation(features){
      const allFeatures = features || this.vector_source.getFeatures();
      const format = new ol.format.GeoJSON();
      const routeFeatures = format.writeFeaturesObject(allFeatures, {decimals: 1});
      //await writeFile(annotationPath, JSON.stringify(routeFeatures))
      //await this.saveConfig()
      routeFeatures['bbox'] = this.current_image_data.bbox;
      feature_string = JSON.stringify(routeFeatures);
      this.current_image_data.mask_geojson = routeFeatures;
    },
    //let features = this.vector_source.getFeatures()
    async exportAnnotation() {
      const allFeatures = this.vector_source.getFeatures();

      const format = new ol.format.GeoJSON();
      const routeFeatures = format.writeFeaturesObject(allFeatures, {decimals: 1});
      routeFeatures['bbox'] = this.current_image_data.bbox;
      const blob = new Blob([JSON.stringify(routeFeatures)], {
          type: "text/plain;charset=utf-8"
      });
      api.alert(JSON.stringify(blob))
    },
    async displayMap(image_url){
      this.vector_source = new VectorSource();
      var vector_layer = new VectorLayer({
        source: this.vector_source,
        style: new Style({
          fill: new Fill({
            color: 'rgba(255, 255, 255, 0.2)'
          }),
          stroke: new Stroke({
            color: '#ffcc33',
            width: 2
          }),
          image: new CircleStyle({
            radius: 7,
            fill: new Fill({
              color: '#ffcc33'
            })
          })
        })
      });
      const select = new Select({
          wrapX: false
      });
      // assuming the current plane is z plane
      const imgObj = await getImageMeta(image_url)
      const extent = [0, 0, imgObj.width, imgObj.height];

      const projection = new Projection({
          code: 'image',
          units: 'pixels',
          extent: extent,
      });

      this.image_source = new Static({
        attributions: '©Human Protein Atlas',
        url: image_url,
        projection: projection,
        imageExtent: extent
      })
      const image_layer = new ImageLayer({
        source: this.image_source,
      })
      // clear map
      document.getElementById('map').innerHTML = ""
      this.map = new Map({
        interactions: ol.interaction.defaults({altShiftDragRotate:false, pinchRotate:false}),
        controls: defaultControls(),
        layers: [
          image_layer,
          vector_layer,
        ],
        target: 'map',
        view: new View({
          projection: projection,
          center: getCenter(extent),
          zoom: 1,
          minZoom: -10
        })
      });
      this.anntation_mode_changed();
      this.map.addControl(new MousePosition({
          coordinateFormat: createStringXY(0)
      }));
      this.map.addInteraction(select);
      select.on('select', (e) => {
          console.log(e.selected, '&nbsp;' +
              e.target.getFeatures().getLength() +
              ' selected features (last operation selected ' + e.selected.length +
              ' and deselected ' + e.deselected.length + ' features)')
      });
      this.select = select
    },
    // add for interaction by hao
    async deleteAnnotation() {
      if (this.vector_source) {
        const features = this.select.getFeatures()
        if(features.getLength()>0){
            features.forEach((feature)=>{
                console.log('removing ', feature)
                this.vector_source.removeFeature(feature);
                this.select.getFeatures().remove(feature);
            });
        }
        else{
            try {
                const answer = await api.confirm({content: "Do you really want to delete the annotations?", confirm_text: 'Yes, delete it.'})
                if (answer) {
                  const features = this.vector_source.getFeatures();
                  features.forEach((feature) => {
                    const ann = this.annotation_types[feature.get('label')]
                    this.vector_source.removeFeature(feature);
                  });
                  this.undo_button_flag = false
                }else{return}
            } catch (err) {
              return;
            }
        }
      //await this.saveAnnotation()
      }
    },
    startAnnotation(source, freehand){
      if(!source){
        console.error("Please specify an annotation layer source")
      }
      if (this.modifyInteraction) {
        this.map.removeInteraction(this.modifyInteraction)
      }
      this.modifyInteraction = new Modify({source: source});
      this.map.addInteraction(this.modifyInteraction);
      if (this.drawInteraction) {
        this.map.removeInteraction(this.drawInteraction)
      }
      this.drawInteraction = new Draw({
        source: source,
        type: 'Polygon',
        freehand: freehand
      });
      this.map.addInteraction(this.drawInteraction);
      if (this.snapInteraction) {
        this.map.removeInteraction(this.snapInteraction)
      }
      this.snapInteraction = new Snap({source: source});
      this.map.addInteraction(this.snapInteraction);

      // if(this.itkInteraction)
      // this.map.removeInteraction(this.itkInteraction);
    },
    stopAnnotation(){
      if(this.drawInteraction)
      this.map.removeInteraction(this.drawInteraction);
      if(this.snapInteraction)
      this.map.removeInteraction(this.snapInteraction);
      if(this.modifyInteraction)
      this.map.removeInteraction(this.modifyInteraction);
    }
  }
})

class ImJoyPlugin {
  async setup() {

  }

  async run(ctx) {

  }
}

api.export(new ImJoyPlugin())
</script>

<window>
  <div style="text-align: center;" id="app">

    <div class="panel centered-panel" v-if="current_panel=='login'">
      <div class="panel-header">
        <div class="panel-title h2">Login</div>
      </div>
      <div class="panel-body">
        <div class="form-group">
          <label class="form-label" for="server">Server</label>
          <select class="form-select" v-model="selected_server_url">
            <option>Choose an option</option>
            <option v-for="(url, k) in servers" :value="url">{{k}}</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label" for="input-example-1">Name</label>
          <input class="form-input" type="text" name="username" v-model="user.username"  placeholder="username">
        </div>
        <div class="form-group">
          <label class="form-label" for="input-example-1">Password</label>
          <input class="form-input" type="password" name="password" v-model ="user.password" placeholder="password">
        </div>
        <button class="btn" @click="login()">Login</button>
      </div>
      <div class="panel-footer">
        <!-- buttons or inputs -->
      </div>
    </div>


    <div class="panel centered-panel" v-if="current_panel=='task_selection'">
      <div class="panel-header">
        <div class="panel-title h2">Please choose a task</div>
      </div>
      <div class="panel-body">
        <br>
        <br>
        <div v-for="task in tasks">
          <progress class="progress" style="width: 288px" :value="task.finished" :max="task.total"></progress>
          <br>
          <button class="btn" style="width: 280px" @click="chooseTask(task.name)"><i class="icon icon-edit"></i>&nbsp; {{task.name}}: {{task.finished}}/{{task.total}}</button>&nbsp;&nbsp;
          <br>
          <br>
        </div>

        <!--<div class="progress">
          <progress class="progress-bar" arial-valuenow= 'tasks[1].finished' aria-valuemin="0" arial-valuemax='tasks[1].total' style="width:10"></progress>&nbsp;&nbsp;
          <br>
          <progress class="progress-bar" arial-valuenow= 'tasks[1].finished' aria-valuemin="0" arial-valuemax='tasks[1].total' style="width:10"></progress>&nbsp;&nbsp;
        </div>-->
      </div>
      <div class="panel-footer">
        <!-- buttons or inputs -->
      </div>

    </div>

    <div class="panel" v-if="current_panel=='imageviewer'">
      <div class="btn-group floating-btn">
        <button class="btn transparent-btn" @click="previousImage()"><i class="icon icon-back"></i>&nbsp;Back</button>
        <button class="btn transparent-btn"><i class="icon icon-check"></i>&nbsp;Yes</button>
        <button class="btn transparent-btn"><i class="icon icon-cross"></i>&nbsp;No</button>
        <button class="btn transparent-btn" @click="nextImage()">Next&nbsp;<i class="icon icon-forward"></i></button>
      </div>
      <span class="h1 floating-label">{{current_image_data.location}}</span>
      <div class="input-group floating-switch">
        <label class="form-switch">
          <input type="checkbox" v-model="anntation_mode" @change="anntation_mode_changed">
          <i class="form-icon"></i> Adjust Mask
        </label>
        <!-- <label class="form-switch" v-if="anntation_mode">
          <input type="checkbox" v-model="freehand_mode" @change="anntation_mode_changed">
          <i class="form-icon"></i> Freehand
        </label> -->
        <button class="btn transparent-btn" v-if="anntation_mode" @click="saveAnnotation()">Save</button>&nbsp;&nbsp;
        <button class="btn transparent-btn" title="delete" v-if="anntation_mode" @Click="deleteAnnotation()"><i class="icon icon-delete"></i></button>&nbsp;&nbsp;
      </div>
      <div v-if="loading" class="loading loading-lg floating"></div>
      <div id="map"></div>
    </div>

    <div class="panel" v-if="current_panel=='navigation'">
      <div class="navigation" style="width:200px">
        <nav class="slds-nav-vertical" aria-label="Sub page">
          <div class="slds-nav-vertical__section">
            <h2 id="entity-header" class="slds-nav-vertical__title">Home</h2>
            <ul aria-describedby="entity-header">
              <li class="slds-nav-vertical__item slds-is-active">
                <!--<a href="javascript:void(0);" class="slds-nav-vertical__action">Login</a>-->
                <a @click="Login()">Login</a>
              </li>
              <li class="slds-nav-vertical__item">
                <a href="javascript:void(0);" class="slds-nav-vertical__action">Progress</a>
              </li>
              <li class="slds-nav-vertical__item">
                <a href="javascript:void(0);" class="slds-nav-vertical__action">Message</a>
              </li>
              <li class="slds-nav-vertical__item">
                <a href="javascript:void(0);" class="slds-nav-vertical__action">Close</a>
              </li>
              <li class="slds-nav-vertical__item">
                <a href="javascript:void(0);" class="slds-nav-vertical__action">All Reports</a>
              </li>
            </ul>
          </div>
        </nav>
      </div>

    </div>
  </div>

</window>
<style lang="css">
  .centered-panel{
    background-color: #448aff0f;
    width: 100%;
    height: 100%;
    max-height: 400px;
    max-width: 400px;
    left: 50%;
    top: 50%;
    position: absolute;
    -webkit-transform: translate3d(-50%, -50%, 0);
    -moz-transform: translate3d(-50%, -50%, 0);
    transform: translate3d(-50%, -50%, 0);
  }
  .ol-layers:first-child{
    background-color: black;
  }
  .navigation { 
      background-color: FAFAFB; 
      color: white; 
      padding: 8px; 
  }
  .floating-label{
    color:#ffefdb96;
    position: absolute;
    left: 50%;
    z-index: 999;
    top: calc(90% - 32px);
    -webkit-transform: translate3d(-50%, -50%, 0);
    -moz-transform: translate3d(-50%, -50%, 0);
    transform: translate3d(-50%, -50%, 0);
  }
  .floating-switch{
    position: absolute;
    right: 10px;
    z-index: 999;
    top: 30px;
  }
  .floating-btn {
    position: absolute;
    left: calc(50% - 180px);
    top: 90%;
    z-index: 999;
  }
  .transparent-btn {
    width: 90px;
    background-color:#fff3;
  }
  .floating {
    position: absolute;
    left: 50%;
    top: 30%;
  }
  #toolbar {
    position: absolute;
    top: 112px;
    left: 10px;
  }
  #toolbar > div:nth-child(1){
    fill: #448aff;
  }

  .ol-layer{
    top: 0px;
  }

  #map{
    height: 100vh;
    min-height: 100px!important;
  }
  .icon::before {
    position: relative;
  }
  .navbar {
    padding-left: 10px;
  }
  .navbar .navbar-brand {
    font-size: 1.5rem;
    text-decoration: none;
  }
  
  .mouse-position{
    padding-left: 124px;
    padding-top: 10px;
  }
  
  @media all and (max-width: 512px) { /* Change Width Here */
    .hide-on-mobile {
        display: none;
    }
  }
</style>
